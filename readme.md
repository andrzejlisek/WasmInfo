# WasmInfo

The main purpose of the **WasmInfo** is reproducing the assembly code and try to reproduce the code in the high level form in the language similato to C language\. Reproduction of the assembly code can be applied at the pusposes, such as:


* Analyze the "boilerplate" code generated by compiler\.
* Compare the code produced by several compilers or several optimization variants\.
* Get the computation code in low\-level form used by WebAssembly\.

Aparts from the code analysis, the **WasmInfo** produces whole information about sections containen in the WebAssembly file\. The information can be used for analysis, such as:


* The name and parameters of the functions, which can be called outside of the WebAssembly file \(export section\)\.
* The name of the functions, which are used by this WebAssembly script \(import section\)\.
* Initial binary data \(global section and data section\)

Most sections splits into the items\. Because the min goal is reading the execution code, not all section features are implemented, especially those not related to execution code reading\.

Application online: [https://andrzejlisek\.github\.io/WasmInfo/index\.html](https://andrzejlisek.github.io/WasmInfo/index.html "https://andrzejlisek.github.io/WasmInfo/index.html") 

# Analyzing the WASM file

In order to analyze the WASM file, you have to browse for file in the **WASM file** field at the top of page\. There is the standard "file" field, which allows to choose file or drop file, depending on operating system and web browser\. Directly after selecting the file, the WASM file will be parsed\.

Parsing bigger WASM files, which size is over about 50kB, may take longer time and the web browser may hang and suggest the breaking script execution\. In such case, allow to contingue script execution and the page will be responsible after WASM file parsing\.

The **WasmInfo** assumes, that the loaded WASM file are correct, including the code correctness\. Trying to parsing incorrect WASM file or other file may cause application crash\.

The WASM file contents consists of sections\. Each section has the identifier indicating section type and section size, which allows to split the WASM file into section without section parsing\. Every WASM file contains 8 bytes before the first section and these bytes are treated as artificial section called **Header**\. The type of each real section is numbered from 0 to 12\. Most sections consists of items, which number can be read before item parsing\.

# Browsing the WASM file

The WebAssembly standard settled the 12 types of sections\. Below the **WASM file field**, there is the list of all sections, which are actually exists in the parsed WASM file\. Each item link into the section information\.

Each section header has the two active elements:


* **Caret** \- Scroll the page to section list\.
* **Section title** \- Collapse or expand the section information\.

The **WasmInfo** has these options to view the file details:


* **Code binary size** \- The number of bytes between address and code text in some sections, which contains the data\.
* **Stack contents** \- Display stack contents for every instruction within disassembled and decompiled code\.
* **Variable declare** \- Declate local and temporary variables at the first occurence\.
* **Hungarian naming style** \- Use hungarian style for naming variables\.

## Section elements

Most sections consists of element list\. Such sections are collapsed in initial display\. These sections has the following elements:


* **List** \- Display all items as summary\. There is default display, every item is displayed as single text line\.
* **Details** \- Display all items as details\. There is detailed display\. In some cases, the detailed display of certain elements is not available and will remain in summary mode\.
* **Raw** \- Display all items as raw using hexadecimal byte layout\.

Every item has active element, which switches the intem between three states mentioned above\. If the detailed information not exists, the active element switches between two states\.

## Code elements

These sections can contain some WebAssembly code:


* **Global** \- mandatory code for value\.
* **Element** \- optional code for offset\.
* **Code** \- main program code\.
* **Data** \- optional code for offset\.

If the item is detailed, there are active two instances of function name:


* **Disassembly** \- The code generated directly from the original WebAssembly code\. The link switches between two states:
  * **Collapsed** \- Display name only\.
  * **Expanded** \- Display disassembled code\.
* **Decompile** \- The code similar to C language, generated from the WebAssembly code\. The link switches between five states \(the identical states are skipped\):
  * **Collapsed** \- Display name only\.
  * **Folded all as possible** \- The stack contents is not visible\.
  * **Filded assignments, unfolded instructions** \- The stack contents is visible, these instructions can not be folded\.
  * **Stack** \- The stack usage is not folded\.
  * **Full** \- The most detailed code, whis is directly generated during decompilation\.

Some code can contains blocks created by **block** and **loop** instructions\. The decompiled code has the **/\*bloop\*/** link, named from **blo**ck and lo**op** names\. The **bloop** switches between three states:


* **Blocks and numbers** \- The decompiled code most similar to original\.
* **Convert numbers into labels** \- The state is avaliable, when the code contains branch instructions\. Into the code, there are added labels and numbers in branch instuctions are replaced with labels\.
* **Flatten lock and loop** \- Remove every **block** and **loop** block and flatten the code\.

The two code versions can be used as code in several programming languages like C, C\+\+, Java, C\#, but is not fully correct as any general\-purpose programming language\. after some additional corrections, such as:


* Data type definition \(for example, define the i32 or f64 type\)\.
* Function implementation, which are used in the code\.

The general purpose of the generated code is understanding the algorithm implemented in the WASM file, not using the code in any programming language\.

The decompilation algorithm is simple and consists of the following steps \(simplified, not exact description\):


* Distinguish and mark the foldable and unfoldable instructions\. The foldable instructions returns exactly one value and can be used as argument in other instruction\.
* Convert the stack machine fashion into the register machine fashion by simulating stack usage as untyped variables\. Each additional stack\-handling instruction is foldable\.
* Write the additional **return** unfoldable instruction to every function, which returns some data\.
* Find the first foldable instruction and places, where the result of the instruction is used\.
* Fold the instruction by removing them and write the instruction in place of the result usage\.
* Find the nest foldable instruction and repeat the action many times, while exists some foldable instructions in the code\.

# Stack contents

Within the code instructions, there can be displayed the stack contents for every single instruction\. The information consists of two elements:


* Stack contents before instruction execution \- input stack\.
* Stack contents after instruction execution \- output stack\.

The stack contents consists of value types from left to right\. There are special characters:


* **Underscore** \- Separator between elements
* **Vertical bar** \- Stack block indicator like **block**, **loop**, **if** instructions\. The whole function is also code block\. Entering and leaving code blocks changes the vertical bar separator\.
* **Asterisk** \- Indicates stack usage by the instruction\. The unused stack part is at the left side and the used stack part is at the right side as following:
  * Input stack \- The parameters, which will be popped before execution\.
  * Output stack \- The results, which will be pushed after execution\.
  * The unused stack part is the same in both input and output stack\.
* **Tilde** \- The stack is after instruction, whick makes the stack contents not applicable until end of block\. The case occurs, when the instruction are dead instruction and WebAssembly does not validate the stack contents\. These instructions are: unreachable, **throw**, **rethrow**, **br**, **return**, **return\_call**, **return\_call\_indirect**\.

# Opcode coverage

The current version of WebAssembly machine language consists of 6 opcode planes\. The main plane is the basic opcode plane\. The five other planes are FB, FC, FD and FE opcode extensions\. Actually, the FD opcode reditects into one of two planes, the secon plane consists of 128 potential opcodes instead of 256 opcodes\. The most opcodes are supported, but not all WebAssembly opcodes are supported\.

Each plane is represented by map consisting of 256 characters\. There are following character meaning in the maps:


* **Dot** \- Instruction not supported\.
* **Comma** \- Instruction not supported, but exists in specification\.
* **Asterisk** \- Instructin implemented\.
* **Tilde** \- Extended instruction set in other plane\.

## Plane 00 \- Main plane

```
**** **** **.* **,*
**** ,,.. ,*** ,..,
**** *,,. **** ****
**** **** **** ***.

.*** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** *... .... ....
***, ,,,. .... ....
.... .... .... ....
.... .... ...~ ~~~.
```

## Plane FB \- Garbage collection and Strings

```
.,,, ,,,. .... ....
.,,, ,,,, .,., ,...
,,,. .... .... ....
.... .... .... ....

,,,, .... ,,,, ....
.... .... .... ....
.... .... .... ....
,,.. .... .... ....

,,,, ,,,, ,,,, ,,,.
,,,, ,,.. ,,,, ,...
,,,, ,... .... ....
,,,, ,,,, .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```

## Plane FC

```
**** **** **** ****
**.. .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```

## Plane FD\-1 \- SIMD instructions

```
**** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ****
**** **** **.* ****
**,* *,,* **** ***,
,*,, ,*** ***. ****

**.* *,,* **** ***,
,*,, ,*** **** ****
**,* **** **** **,*
**** **** **** ****
```

## Plane FD\-2 \- Relaxed SIMD instructions

```
.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

**** **** **** ****
**** *... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```

## Plane FE \- Threads

```
**** .... .... ....
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ***.
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```




