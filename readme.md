# WasmInfo

The main purpose of the **WasmInfo** is reproducing the assembly code and try to reproduce the code in the high level form in the language similato to C language\. Reproduction of the assembly code can be applied at the pusposes, such as:


* Analyze the "boilerplate" code generated by compiler\.
* Compare the code produced by several compilers or several optimization variants\.
* Get the computation code in low\-level form used by WebAssembly\.

Aparts from the code analysis, the **WasmInfo** produces whole information about sections containen in the WebAssembly file\. The information can be used for analysis, such as:


* The name and parameters of the functions, which can be called outside of the WebAssembly file \(export section\)\.
* The name of the functions, which are used by this WebAssembly script \(import section\)\.
* Initial binary data \(global section and data section\)

Most sections splits into the items\. Because the min goal is reading the execution code, not all section features are implemented, especially those not related to execution code reading\.

Application online: [https://andrzejlisek\.github\.io/WasmInfo/index\.html](https://andrzejlisek.github.io/WasmInfo/index.html "https://andrzejlisek.github.io/WasmInfo/index.html") 

# Analyzing the WASM file

In order to analyze the WASM file, you have to browse for file in the **WASM file** field at the top of page\. There is the standard "file" field, which allows to choose file or drop file, depending on operating system and web browser\. Directly after selecting the file, the WASM file will be parsed\.

Parsing bigger WASM files, which size is over about 50kB, may take longer time and the web browser may hang and suggest the breaking script execution\. In such case, allow to contingue script execution and the page will be responsible after WASM file parsing\.

The **WasmInfo** assumes, that the loaded WASM file are correct, including the code correctness\. Trying to parsing incorrect WASM file or other file may cause application crash\.

The WASM file contents consists of sections\. Each section has the identifier indicating section type and section size, which allows to split the WASM file into section without section parsing\. Every WASM file contains 8 bytes before the first section and these bytes are treated as artificial section called **Header**\. The type of each real section is numbered from 0 to 12\. Most sections consists of items, which number can be read before item parsing\.

# Browsing the WASM file

The WebAssembly standard settled the 12 types of sections\. Below the **WASM file field**, there is the list of all sections, which are actually exists in the parsed WASM file\. Each item link into the section information\.

Each section header has the two elements:


* **Caret** \- Scroll the page to sectin list\.
* **Minus** or **Plus** \- Collapse or expand the section information\.

The **WasmInfo** has these options to view the file details:


* **Section raw binary** \- The binary data of the whole section in hexadecimal form\.
* **Item information** \- The basic item information in section, which contains the items\. If the item has some execution code \(**Global**, **Code**, **Data**\), the incorrectly parsed code will be indicated as **ERROR** message\. These information consists of the several elements:
  * Item number\.
  * Item address in the WASM file in hexadecial form\.
  * Additional information depending on section\.
* **Item raw binary** \- The binary data of each item separately\.
* **Item details** \- The item details depending on section and item\.
* **Code binary size** \- The number of bytes between address and code text in some sections, which contains the data\.
* **Code kind** \- The code kind to display in execudion code containing sections:
  * **Function names** \- Display the function names without function body\.
  * **Disassembled** \- Display the disassembled code only\.
  * **Decompiled** \- Display the decompiled code only\. If the disassembled code contains any error, the decompiled code will be displayed as empty function\.
  * **Both** \- Display both disassembled and decompiled code simultaneously
* **Branches** \- Branch interpretation and conversion in decompiled code:
  * **Keep as numbers** \- Display unprocessed numbers in branch instructions\.
  * **Convert into labels** \- Insert labels into code and replace the numbers with label names\.
  * **Flatten block/loop** \- Convert numbers into labels and flatten every **block** and **loop** instruction\.
* **Control flow** \- Style of decompiled code flow:
  * **Details** \- Write detailed parameter assignmend from stack and result assignment to stack\.
  * **Stack** \- Write stack assignment as parameters and results\. The code remains unfolded\.
  * **Partial fold** \- Fold some assignment instructions, but keep most instruction for stack contents\.
  * **Fold** \- Fold all instrucions as possible\. The stack contents will not be displayed\.
* **Stack contents** \- Display stack contents for every instruction within disassembled and decompiled code\.
* **Variable declare** \- Declate local and temporary variables at the first occurence\.
* **Hungarian naming style** \- Use hungarian style for naming variables\.

# Execution code analysis

Some sections, especially the **Code** section, may consist the executable code written in WebAssembly machine code\. Such code are written in the three forms:


* **The raw binary code** \- Each instruction is written as byte sequence including opcode and hardcoded parameters\.
* **The C\-like assembly code** \- The human\-readable code which is the exact reproduction of binary code\. The code format is inpired by the C language and mnemonic are renamed to be a correct identifiers, like replace dot character into underscore character\. Additionally, there are written the function names and varialbe types based on the information from other section\. The varialbe types and called function name are written as commend for more clarity\.
* **The C\-like decompiled code** \- The second version of function written below is the simply decompiled code\. The decompiling algorithm assumes, that the WebAssembly code has correct stack handling\. In some cases, the simple functions, especially mathematical operations, may look similarly to the optimized soruce code uded to compile the WASM file\.

The two code versions can be used as code in several programming languages like C, C\+\+, Java, C\#, but is not fully correct as any general\-purpose programming language\. after some additional corrections, such as:


* Data type definition \(for example, define the i32 or f64 type\)\.
* Function implementation, which are used in the code\.

The general purpose of the generated code is understanding the algorithm implemented in the WASM file, not using the code in any programming language\.

The decompilation algorithm is simple and consists of the following steps \(simplified, not exact description\):


* Distinguish and mark the foldable and unfoldable instructions\. The foldable instructions returns exactly one value and can be used as argument in other instruction\.
* Convert the stack machine fashion into the register machine fashion by simulating stack usage as untyped variables\. Each additional stack\-handling instruction is foldable\.
* Write the additional **return** unfoldable instruction to every function, which returns some data\.
* Find the first foldable instruction and places, where the result of the instruction is used\.
* Fold the instruction by removing them and write the instruction in place of the result usage\.
* Find the nest foldable instruction and repeat the action many times, while exists some foldable instructions in the code\.

# Stack contents

Within the code instructions, there can be displayed the stack contents for every single instruction\. The information consists of two elements:


* Stack contents before instruction execution \- input stack\.
* Stack contents after instruction execution \- output stack\.

The stack contents consists of value types from left to right\. There are special characters:


* **Underscore** \- Separator between elements
* **Vertical bar** \- Stack block indicator like **block**, **loop**, **if** instructions\. The whole function is also code block\. Entering and leaving code blocks changes the vertical bar separator\.
* **Asterisk** \- Indicates stack usage by the instruction\. The unused stack part is at the left side and the used stack part is at the right side as following:
  * Input stack \- The parameters, which will be popped before execution\.
  * Output stack \- The results, which will be pushed after execution\.
  * The unused stack part is the same in both input and output stack\.
* **Tilde** \- The stack is after instruction, whick makes the stack contents not applicable until end of block\. The case occurs, when the instruction are dead instruction and WebAssembly does not validate the stack contents\. These instructions are: unreachable, **throw**, **rethrow**, **br**, **return**, **return\_call**, **return\_call\_indirect**\.

# Opcode coverage

The current version of WebAssembly machine language consists of 6 opcode planes\. The main plane is the basic opcode plane\. The five other planes are FB, FC, FD and FE opcode extensions\. Actually, the FD opcode reditects into one of two planes, the secon plane consists of 128 potential opcodes instead of 256 opcodes\. The most opcodes are supported, but not all WebAssembly opcodes are supported\.

Each plane is represented by map consisting of 256 characters\. There are following character meaning in the maps:


* **Dot** \- Instruction not supported\.
* **Comma** \- Instruction not supported, but exists in specification\.
* **Asterisk** \- Instructin implemented\.
* **Tilde** \- Extended instruction set in other plane\.

## Plane 00 \- Main plane

```
**** **** **.* **,*
**** ,,.. ,*** ,..,
**** *,,. **** ****
**** **** **** ***.

.*** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** *... .... ....
***, ,,,. .... ....
.... .... .... ....
.... .... ...~ ~~~.
```

## Plane FB \- Garbage collection and Strings

```
.,,, ,,,. .... ....
.,,, ,,,, .,., ,...
,,,. .... .... ....
.... .... .... ....

,,,, .... ,,,, ....
.... .... .... ....
.... .... .... ....
,,.. .... .... ....

,,,, ,,,, ,,,, ,,,.
,,,, ,,.. ,,,, ,...
,,,, ,... .... ....
,,,, ,,,, .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```

## Plane FC

```
**** **** **** ****
**.. .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```

## Plane FD\-1 \- SIMD instructions

```
**** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ****
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ****
**** **** **.* ****
**,* *,,* **** ***,
,*,, ,*** ***. ****

**.* *,,* **** ***,
,*,, ,*** **** ****
**,* **** **** **,*
**** **** **** ****
```

## Plane FD\-2 \- Relaxed SIMD instructions

```
.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

**** **** **** ****
**** *... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```

## Plane FE \- Threads

```
**** .... .... ....
**** **** **** ****
**** **** **** ****
**** **** **** ****

**** **** **** ***.
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....

.... .... .... ....
.... .... .... ....
.... .... .... ....
.... .... .... ....
```




